오픈소스를 활용한 DevOps 환경 이해 강좌에 오신 것을 환영합니다.

1주차는 DevOps와 오픈소스 소프트웨어 라는 주제로 강의가 진행될 예정입니다.

학습목표는

1. DevOps와 오픈소스 소프트웨어의 주요 개념을 이해할 수 있다.

2. DevOps 주요 활동과 사례를 통해 DevOps 공정을 이해할 수 있다.

3. DevOps 영역 별 대표적인 오픈소스 도구에 대해서 파악할 수 있다.

입니다.

Week 01

안녕하세요? SK주식회사 CNC 이정민 수석입니다.
오픈소스를 활용한 데브옵스 환경에 의해 강좌의 첫 번째 시간, 데브옵스와 오픈소스 소프트웨어 강의를 시작합니다.
이번 주 차 강의를 통해서 여러분은 데브옵스와 오픈소스 소프트웨어의 주요 개념을 이해하고 데브옵스의 주요 활동과 공정을 이해하실 수 있습니다.
이해를 돕기 위해서 데브옵스의 주요 영역별 사례와 대표적으로 사용되는 오픈소스 도구도 함께 소개해드리겠습니다.
요즘 시대를 4차 산업혁명의 시대라고 합니다.
기술 변화는 가속화되고 있고 제조, 서비스, 의료, 금융 등 산업 전반에서 소프트웨어를 기반으로 새로운 서비스들이 쏟아지고 있습니다.
고객의 새로운 요구를 맞추기 위해서 매일 새로운 앱들이 출시되고 있고, 이미 출시된 앱들도 하루가 멀다 하고 업그레이드 되는 상황입니다.
한 번 출시되고 사용된다고 해서 일이 끝난 것이 아닙니다.
미래는 불확실하고 고객의 요구와 시장의 변화는 종잡을 수 없기 때문에 한 번에 성공하기란 하늘의 별따기와 같습니다.
시장의 변화와 고객의 요구를 빠르게 대응하는 것이 중요합니다.
빠르게 시도해보고, 빠르게 실패하면서 시행착오와 반복을 통해서 점진적으로 서비스를 개선해 나가는 것만이 현재로써는 최선의 방법입니다.
이를 위해서 신속하게 소프트웨어를 개발하고 변경할 수 있어야 합니다. 그리고 변경된 내용이 문제는 없는지 검증도 철저히 해야 합니다.
그리고 이 과정은 실수없이 지속적으로 반복되어야 하는데 과연 정말 이런 방식으로 소프트웨어 서비스를 개발하고 운용할 수 있을까요? 이것에 대한 해답이 바로 데브옵스입니다.
데브옵스는 기술과 시장의 빠른 변화에 대응하기 위한 최신의 소프트웨어 개발 운영 트렌드입니다.
데브옵스란 용어는 소프트웨어 개발을 뜻하는 디벨롭먼트와 운영을 뜻하는 오퍼레이션의 합성어입니다.
기존에는 개발과 운영, 단계로 나누고 개발과 운영 업무를 나누고 개발과 운영 팀을 나누어서 일을 했다면 데브옵스는 개발과 운영의 컬래버레이션을 추구하는 방식입니다.
과거에는 역할에 따라 경계를 나누었기 때문에 일하는 데 장벽이 있었습니다.
실제로 일을 하다보면 가장 큰 문제는 이 역할과 경계에 속하지 않는 회색지대에서 발생하게 됩니다. 많은 분이 공감하실 겁니다.
데브옵스는 소통과 협업을 통해서 경계와 장벽을 없애려는 노력이고, 통합을 중요시하는 사상입니다. 사상이라는 단어로 표현하는 이유가 있습니다.
데브옵스는 특정한 기술이나 도구만을 지칭하는 것이 아니라 프로세스, 조직, 문화 등을 망라하는 매우 포괄적인 개념이기 때문입니다.
중요한 것은 서비스입니다. 고객에게 제공하는 서비스가 제일 중심에 있고, 그 서비스를 원활하게 제공하기 위해서 필요한 것.
그것을 서비스 중심으로 통합하는 것이 데브옵스의 시작입니다. 그렇다면 서비스 중심으로 통합한다는 것은 무엇인지 살펴보겠습니다.
개발은 요구사항에 따라서 아키텍쳐에 기반 한 설계 개발을 수행합니다. 운영은 그 개발의 결과물을 안정적으로 서비스하기 위한 활동입니다.
이 모든 것을 일정 수준의 품질로 유지하지 못한다면 실패할 확률이 높아집니다.
즉 개발, 운영, 품질 이 세 가지 요소는 개별적으로는 의미가 있는 것이 아니라 통합적으로 잘 이루어질 때 의미가 있습니다.
그림에서 보듯이 개발, 운영, 품질이 통합되는 교집합에 바로 데브옵스가 있습니다. 보통 이 교집합 부분에서 제일 많은 병목과 지연, 비용이 발생합니다.
좋은 품질의 서비스를 지속적으로 개선하면서도 안정적으로 제공하려면 바로 이 교집합, 통합적 관점으로 접근해야 합니다.
그래서 본 강좌는 특정한 부분만을 중심적으로 다루지는 않습니다.
개발 영역, 요구사항, 아키텍쳐 설계 개발의 구체적이고 상세한 내용은 마이크로 서비스 설계 개발 강좌를 참고하시기 바랍니다.
본 강좌는 개발과 운용의 전반적인 흐름, 특히 1주차에서 4주차까지는 개발 운용을 지속적으로 통합하는 측면을 다룰 예정입니다.
5주차부터는 품질 측면에서 소스 코드, 정적 분석, 리펙토링, 테스트 전반을 다룰 예정입니다.
그렇다면 데브옵스를 통해서 달성하고자 하는 것은 무엇일까요? 첫 번째는 소프트웨어를 더 빠르고 더 자주 배포하는 것입니다.
한 달에 한 번에서 일주일에 한 번으로, 하루에 한 번으로. 더 나아가 매시간 수시로 변경 배포할 수 있어야 합니다.
만일 배포를 자주 실패한다거나 실패했을 때 복구가 어렵다면 빠르고 자주 배포하는 것은 의미가 없을 것입니다.
실패할 확률은 낮추고 실패하더라도 빠르게 복구가 가능해야 합니다. 높은 품질의 서비스를 안정적으로 제공하는 것이 핵심입니다.
이를 위해서 시간과 비용이 많이 들고 실수할 여지가 많은 사람 중심의 수작업이 아니라 시스템 기반으로 자동화하고 모든 과정은 자동으로 측정되어야 합니다.
궁극적으로 이 모든 것은 비용을 절감하기 위한 것입니다.
데브옵스의 목표는 서비스를 지속적으로 개선하고 제공하기 위하여 최소의 비용으로 최고의 효율을 추가하는 것이라고 할 수 있습니다.
그렇다면 데브옵스가 가능해진 가장 큰 이유가 무엇일까요? 여러 가지 이유를 생각해볼 수 있겠지만 저는 가장 근본적인 이유로 오픈소스 소프트웨어 모델의 성공을 꼽고 싶습니다.
데브옵스를 이루는 많은 기술은 오픈소스 소프트웨어를 기반으로 합니다. 오픈소스 소프트웨어는 이미 대중화되었고 소프트웨어 산업 전반에서 대세가 되었습니다.
이미 검증된 오픈소스 소프트웨어가 폭넓게 퍼져 있습니다.
데브옵스 환경은 상황에 따라 다양한 소프트웨어로 구성되고 조합하게 되는데 이때 오픈소스 소프트웨어의 유연성, 호환성은 매우 큰 장점입니다.
특히 상황에 따라 소스 코드 변경이 필요한 경우 즉각적으로 조치가 가능하기 때문에 기술과 시장의 변화에 빠르게 대응해야 하는 데브옵스에 매우 적합합니다.
구글, IBM, 마이크로소프트, 페이스북, 넷플릭스 등 최첨단의 아이디어와 기술을 선도하는 기업들이 오픈소스를 주도하고 있습니다.
오픈소스 프로젝트를 직접 이끌거나 지원하고 있으며 주요 오픈소스 프로젝트를 이끄는 기업들을 인수하기도 합니다.
공유와 협업을 기반으로 하는 오픈소스 커뮤니티가 활성화되면 될수록 데브옵스를 위한 새로운 아이디어가 시도되고 활발해질 것입니다.
이것은 기업의 비용절감과 효율성을 제고시켜서 기업의 경쟁력을 강화시켜줄 것이고, 이것은 다시 지속적으로 선순환 생태계를 이룰 것입니다.
오픈소스 소프트웨어에 대해서 조금 더 살펴보겠습니다. 오픈소스 설명은 매우 방대해질 수 있습니다.
하지만 이 강좌에서는 오픈소스라는 개념 자체에 대한 이해보다는 오픈소스 소프트웨어를 직접 사용해보는 데 중심을 둘 것입니다.
따라서 설명은 간단한 상식 이해를 위한 수준으로 소개해드리고자 합니다.
오픈소스 소프트웨어란 소스코드를 공개하여 특별한 재원없이 사용 가능한 소프트웨어를 말합니다.
원 저작자가 정해놓은 범위, 라이선스에 따른 의무를 따르는 범위 내에서는 소스 코드를 자유롭게 사용할 수 있습니다.
누구에게나 열려있기 때문에 소스코드를 열람하거나 프로젝트에 직접 참여할 수 있습니다. 단순히 사용만 할 수도 있고 프로젝트에 도움을 주는 컨트리뷰터로 활동할 수도 있습니다.
혹은 조금 더 적극적으로 권한과 책임을 가지는 일에 참여할 수도 있습니다. 오픈소스의 장점은 저비용으로 자유롭게 소스코드를 복제, 수정, 배포할 수 있다는 것입니다.
반면 단점은 공개의 의무가 있고 직접 운영, 유지, 보수하는 것은 쉽지 않습니다. 하지만 비용을 들여서 유지 보수 및 지원 서비스를 받을 수는 있습니다.
오픈소스 라이선스는 오픈소스 소프트웨어 이용에 대한 조건을 규정한 것으로 위반 시 리스크가 있습니다.
오픈의 의미는 누구에게나 개방한다는 의미이지 모든 것이 허용되는 것은 아니고 무료라는 것도 아니기 때문입니다.
실제로 기업 활동에서 오픈소스 사용과 관련된 리스크는 매우 크기 때문에 오픈소스 사용을 전담하여 관리하고 있습니다.
오픈소스 사용을 잘못 사용한 경우에는 핵심 제품의 소스 코드를 공개해야 하거나 저작권 침해로 소송을 당하는 상황이 발생할 수 있기 때문에 주의해야 합니다.
오픈소스 라이선스는 단일한 형태가 아니고 매우 방대하고 복잡합니다. 대표적인 오픈소스와 라이선스에 대해서 짧게 살펴보겠습니다.
위에서부터 아래로 리스크가 높은 순서입니다. 리눅스 커널과 마리아DB는 GPL 라이선스입니다.
소스 수정뿐 아니라 링크에서 사용하더라도 소스를 공개해야 하는 의무가 있습니다. 빅데이터 분야에 대표적인 오픈소스 프로젝트인 하둡은 아파치 라이선스입니다.
아파치 라이선스는 특별한 공개의 의무나 범위는 없습니다.
오픈소스 라이선스별 주요 의무사항에 대해서 조금 더 살펴보겠습니다.
복제, 배포, 수정, 권한의 허용, 배포 시 라이선스 사본 첨부, 저작권 고지사항 유지, 수정내용 고지 등의 의무사항이 있습니다.
왼쪽에서부터 오른쪽 방향으로 라이선스별 지켜야 할 의무사항이 많습니다.
오픈소스 라이선스는 기업 활동에서 매우 리스크가 있을 수 있기 때문에 정확한 내용은 법무팀 또는 변호사와 상담이 필요합니다.
정보통신산업진흥원의 공개 소프트웨어 포탈이나 한국저작권위원회의 오픈소스 소프트웨어 라이선스 종합정보시스템을 참조하시기 바랍니다.

2차시 데브옵스입니다. 데브옵스의 수명 주기에 대해서 알아보겠습니다. 계획, 개발, 빌드, 테스트, 릴리즈, 배포, 운영, 모니터링. 보통 계획에서 테스트까지를 개발이라고 합니다.
좌측은 사람, 우측은 컴퓨터 시스템이라고 보면 좌측의 사람들이 협업을 통해서 소프트웨어를 개발하고 우측의 컴퓨터 시스템에서 작동할 수 있도록 산출물을 만드는 과정입니다.
그리고 릴리즈에서 모니터링까지를 일반적으로 운영이라고 하는데, 우측 컴퓨터 시스템에서 작동하는 서비스를 좌측의 사람들에게까지 제공하는 활동입니다.
과거 개발의 경우에는 설치형 또는 패키지 소프트 위주로 개발하였습니다.
사용자는 PC에 패키지 소프트웨어를 설치하거나 인터넷에서 다운받아 설치하는 사용하는 방식입니다.
과거 운용의 경우에는 기업 혹은 정부 전산실에서 특수한 목적을 위해 사용하는 특정한 서비스만을 제공하였습니다.
개발된 소프트웨어를 운용할 수 있도록 전산실에 장비를 설치하여 운영하는 방식인데
개발이 완료되더라도 시스템을 구축하는 데 장시간이 걸리고 소프트웨어의 변경사항을 변경하는 데에도 많은 시간이 필요하였습니다.
개발과 운용의 전환 주기는 최소 수개월에서 수년이 걸릴 수도 있었는데 대규모 시스템인 경우 보통 차세대라고 하는 빅뱅 방식으로 이루어졌습니다.
하지만 대부분의 차세대 프로젝트들은 기간 지연, 비용 증가의 문제가 발생했습니다. 데브옵스의 수명 주기는 개발과 운용의 갭을 최소화시킵니다.
그러기 위해서 큰 기능을 한 번에 완료시키는 것이 아니라 작은 기능을 여러 번에 걸쳐서 반복적이고 지속적으로 개선합니다.
기능 개선 계획부터 빌드, 릴리즈, 서비스 제공, 모니터링까지 짧게는 2주, 길게는 1개월 정도로 단축시킵니다. 서비스 전체로 보면 매일 작은 기능들이 빌드되고 배포됩니다.
이것은 클라우드 컴퓨팅, 컨테이너 기술 등이 발달하여 과거에는 사람이 수작업에 의존해서 작업했던 내용들이 자동화되어 수행되기 때문에 가능해졌습니다.
데브옵스의 수명주기는 사스를 위한 방식입니다.
사스는 Software As A Service의 줄임말인데 사용자가 소프트웨어를 구매하고 설치하여 사용하는 것이 아니라 서비스로써 사용하는 개념입니다.
예를 들면 과거에는 오피스 프로그램을 직접 구매, 설치해서 사용했다면
지금은 인터넷이 되는 환경이라면 PC, 모바일 환경을 불문하고 별도의 소프트웨어 설치 없이 서비스에 접속하여 사용할 수 있습니다.
구글 문서, 스프레드시트, 프레젠테이션이 대표적인 예라고 할 수 있습니다. 마이크로소프트사도 오피스365라는 서비스를 제공합니다.
과거에는 특별한 소프트웨어들이 서비스로 개발되어 운영되었다면 요즘은 거의 대부분의 소프트웨어가 서비스로써 개발되어 운영되고 있습니다.
데브옵스 구간별 협업 활동에 대해서 설명 드리도록 하겠습니다. 계획과 개발의 협업을 위한 활동으로 에자일 개발이 있습니다.
계획은 서비스 개선을 계획하고 추적하는 활동입니다. 변경이 필요한 요구사항을 검토하고 개선을 위한 작업 계획을 수립합니다.
우선순위에 따라서 요구사항을 조정하고 작업사항을 가시화하며 추적 관리합니다.
이 활동은 개인 차원이 아니라 이해관계자들 간의 협업으로 이루어지기 때문에 사람들 간의 협업을 위한 도구나 방법이 필요합니다.
이를 위해서 보통 스크럼 또는 칸반이라고 하는 방식을 사용합니다. 개발은 소프트웨어를 설계하고 코드를 작성하는 활동입니다. 개발 역시 다수 사람들의 협업으로 이루어집니다.
하나의 소스코드 저장소를 통해 다수의 인원이 작업하기 때문에 변경사항에 대한 소스코드 버전 관리가 필수적입니다.
테스트 자동화를 위한 테스트 코드 작성도 개발 단계에서 이루어져야 합니다.
단순히 기능을 구현하는 수준에 머무르는 것이 아니라 코드 인스펙션과 동료검토를 거치면서 소스 코드 품질 향상을 위한 임펙토링도 이루어져야 합니다.
특히 사스 개발을 위한 필수요건은 설계 및 코딩에 반영되어야 합니다.
코드 관리 방안, 무상태 프로세스를 가지는 서비스, 보완을 포트바인딩, 동시성 처리, 로그 처리 방안 등은 필수적으로 고려되어야 합니다.
지속적 통합은 앞서 설명 드린 에자일 개발을 확장하여 빌드 테스트까지 통합하는 협업 활동입니다.
빌드 테스트는 실행 가능한 소프트웨어 산출물을 만들고 테스트 하는 활동입니다. 소스 코드 컴파일, 단위 테스트, 패키징, 통합 테스트의 과정을 거칩니다.
의존성이 있는 라이브러리와 모듈들을 통합하는 것은 매우 까다로운 작업입니다.
개발자들은 항상 작업 전에는 통합된 최신 소스코드를 업데이트해야 하고 작업은 작은 단위로 수행해야 합니다.
빌드가 정상적이고 테스트가 정상인지 필히 확인한 다음에 변경사항은 즉각적으로 반영해야 합니다.
완벽하게 빌드 되지 않은 코드는, 그리고 테스트 되지 않은 코드는 작업에 지연, 병목을 일으키게 합니다.
개발자들이 작업 반영을 느리게 하면 할수록 통합의 지연이 발생할 수 있기 때문에 지속적으로 개발팀의 소스 코드는 최신화 되어 통합 유지되는 것이 중요합니다.
지속적 전달 배포는 지속적 통합을 확장하여 릴리즈 배포까지 통합하는 활동입니다. 릴리즈 배포는 언제나 소프트웨어를 배포하서 실행 가능한 상태로 유지하는 활동입니다.
릴리즈는 가장 큰 병목과 지연이 발생하는 구간입니다. 기존에 운영되는 서비스에서 운영 환경을 준비하고 문제가 발생하는 경우 롤백 대응까지 포함해야 합니다.
UI테스트, 부하 테스트, 통합 테스트 등 다양한 테스트도 필수적입니다.
지속적 전달은 테스트가 성공하면 스테이징 환경까지 배포하고 그 이후의 프로덕션 배포는 사람에 의해서 수동으로 이루어집니다.
프로덕션 환경까지 자동으로 배포하는 것을 지속적 배포라고 합니다.
이 구간을 완전히 모든 것을 자동화 구현하는 것은 매우 어려운 일이기 때문에 처음부터 완성하기보다는 반복적으로 수행해 나가면서 개선할 수 있습니다.
지속적 서비스 전달 개선 활동은 지속적 배포를 확장하여 운영 모니터링까지 통합하는 활동입니다. 운영 모니터링은 사용자에게 중단 없는 서비스를 제공하는 활동입니다.
장애, 성능, 보완, 용량, 가용성을 관리하고 애플리케이션 및 인프라 구성 변경을 관리합니다.
운영 상태에서 이벤트 및 로그를 통해 성능과 품질을 모니터링하고 성과 영역별 최대 목표 수준에 도달할 수 있도록 서비스 수준을 관리합니다.
분석을 통해서 개선사항을 도출하여 개선 계획에 반영하여 적용하는 것, 그리고 이것을 지속적으로 수행하는 것을 지속적 서비스 개선이라고 할 수 있습니다.
지속적 서비스 개선까지 이루는 것이 가장 이상적으로 데브옵스를 구현하는 것이지만 현실적으로는 조직의 성숙도에 따라서 구현할 수 있는 수준부터 적용해 나가는 것이 첫걸음입니다.
지금까지 데브옵스 과정에서 주요 활동에 대해서 살펴보았습니다.
다음 차시에서는 각 공정별 주요 활동 사례를 통해서 실제 프로젝트에 어떻게 적용되는지 알아보도록 하겠습니다.

니다. 설명 드리는 예시는 모두 저희 회사에서 실제 적용하고 있는 사례입니다.
실제 스크럼 활동 중 유저 스토리 워크숍을 진행하는 상황입니다. 유저 스토리 워크숍을 통해서 개발해야 할 내용. 즉, 제품 백로그 아이템을 식별하고 있습니다.
이 과정에서는 사람들 간의 아이디어 교환, 소통 등의 협업을 통해서 제품에 담고자 하는 기능과 우선순위를 정리합니다.
포스트잇을 활용해서 자신의 생각을 표현하고 내용을 간략하게 정리합니다.
그리고 다른 사람들에게 설명하면서 사용자가 요구하는 기능의 구체적인 사용 사례, 흐름까지 스토리로 도출합니다. 앞서 도출한 내용들은 도구를 활용하여 추적 관리할 수 있습니다.
화면은 아틀란시아사의 지라라는 도구를 사용하여 백로그 아이템을 등록한 모습입니다. 이 도구는 에자일 개발에 있어 가장 대중적으로 사용하는 상용 소프트웨어 중 하나입니다.
실제 기업 환경에서는 모든 것을 다 오픈소스 소프트웨어로 사용할 수는 없습니다.
특히 계획 단계 활동은 개발자가 아닌 많은 사람과 협업이 이루어지기 때문에 사용자들에게 익숙하고 편리함을 제공할 수 있는 기능, 그리고 쉽게 지원을 받을 수 있는 도구가 필요합니다.
따라서 상대적으로 다른 활동과 비교하여 상용 소프트웨어를 많이 사용하게 됩니다.
스프린트 수행을 위한 일감 관리 화면입니다. 스크럼에서 실제 개발을 위해서는 2주에서 1개월 주기로 반복하는 활동을 스프린트라고 합니다.
단거리 질주라는 뜻의 스프린트처럼 스프린트 기간 중에는 긴박하게 목표를 향해서 질주하듯이 개발을 진행합니다.
해야 할 일감, 진행 중인 일감, 해결된 일감, 그리고 완료된 일감 등 계획한 내용이 어떻게 진행되는지 추적, 관리합니다.
도메인 주도 설계는 업무 중심으로 소프트웨어를 설계하고 개발하는 방식입니다.
업무를 중심으로 업무 담당자와 개발자들 간 공통의 언어와 개념을 맞추고 설계와 개발을 진행하는 방식입니다.
따라서 다양한 이해관계자들 간의 아이디어 교환, 소통 등이 협업으로 이루어집니다.
이벤트 스토밍을 통해서 참석자들이 자유롭게 의견을 교환하고 수용하면서 팀원의 의견이 반영된 최종적으로 설계 결과를 얻을 수 있습니다.
화면은 자유로운 아이디어를 색상별로 의미 있게 포스트잇으로 표현하면서 정형화된 형태로 구현해 나가는 과정입니다.
전략적 설계에서는 설계의 전체적인 큰 그림을 잡고 이를 바탕으로 개발해야 할 마이크로서비스를 식별합니다.
사진은 도출된 내용을 가지고 참여자들이 내용을 토의하면서 공유하는 모습입니다. 전술적 설계는 실제 개발을 위한 활동입니다.
앞서 전략적 설계의 결과를 가지고 구체적인 클래스들을 식별하고 모델링하는 작업입니다. 모델링 된 결과가 어떻게 표현되는지 UI와이어 프레임과 함께 설계하기도 합니다.
사용자 스토리 진행을 모두 다 반영할 수 있는지 모델을 지속적으로 개선해 가면서 개발팀의 구체적인 일감을 정의해 나갑니다.
포스트잇과 화이트보드에서 설계한 내용을 별도로 다이어그램을 그리지 않고 바로 코딩한 다음에 소스코드 역공학을 통해서 다이어그램을 자동으로 생성하여 활용합니다.
이를 통해서 설계와 코딩의 갭과 시간을 줄일 수 있습니다. 또한 모델과 코드를 신속하게 리펙토링 하는 데 도움이 됩니다.
다음은 사스 구현의 한 가지 예를 설명 드리겠습니다. 다양한 환경에 배포하더라도 하나의 코드가 기반이 되어야 합니다.
예를 들면 웹이든 모바일이든 채널이 다르더라도 하나의 소스 코드로 배포할 수 있어야 합니다.
마찬가지로 개발 환경이든 스테이징 환경이든 프로덕션 환경이든 구분 없이 하나의 소스 코드가 유지되어야만 하며, 이를 위해서는 환경설정 등의 정보는 코드와 분리하여 관리해야 합니다.
이것이 분리되지 않으면 채널별, 상황별, 코드 관리 요소가 커지면서 간단한 수정도 제대로 할 수 없는 어려움에 직면하게 됩니다.
사스 구현을 위한 상세한 내용은 아래 사스 구현 방법론 사이트를 참조하시기 바랍니다.
통합 데브옵스 환경입니다. 저희 회사에서 사용하는 클라우드ZCP라고 하는 컨테이너 플랫폼입니다.
컨테이너 기반으로 로드 밸런싱, 오토 스케일링 등의 서비스 운용 환경을 제공하며 모니터링, 로깅, 지속적 전달 배포 등 다양한 에드원 서비스를 제공합니다.
제공되는 서비스를 조금 더 살펴보면 플랫폼 기반의 자동화된 애플리케이션 관리를 위한 지속적 통합 배포 서비스, 그리고 다양한 자원의 모니터링, 로깅 관리를 하는 서비스.
데시보드를 통한 플랫폼 구성 자원 관리를 할 수 있는 서비스 등을 제공합니다. 데시보드를 통해 다양한 수준의 로깅을 수집하고 시각화해주는 화면입니다.
지금 보시는 화면은 로깅 기반의 리소스 관리 데시보드 화면입니다.
지속적 통합, 전달, 배포를 위하여 젠킨스를 사용하고 있으며 무 중단 배포를 위한 블루그린 배포, 롤링 업데이트를 적용하고 있습니다.
실제 프로젝트의 파이프라인입니다. 이것으로 3차시 데브옵스 사례 소개를 마치겠습니다.

오픈소스 DevOps 도구를 설명 드리겠습니다. 앞서 설명 드린 DevOps 수명 주기 전반의 도구 사슬을 표현하였습니다.
도구 사슬의 의미는 각 영역이 별개가 아니라 도구 간 연계를 통해서 시너지를 이룬다는 측면을 강조한 것입니다. 각 영역별로 오픈소스 위주의 도구를 나열하였습니다.
이 중 로고로 표시한 도구는 향후 실습에서 직접 사용해볼 도구들입니다.
계획 영역에서는 협업, 일감 관리를 위한 도구를 주로 사용합니다. Redmine이 잘 알려진 오픈소스 도구이며, 실제 기업 환경에서는 상용 도구를 주로 사용하기도 합니다.
개발 영역에서는 코드 버전 관리를 위한 도구를 주로 사용합니다. 과거에는 Subversion이라는 전통적인 도구를 많이 사용했지만, 최근에는 분산 환경에 적합한 Git을 많이 사용합니다.
빌드 영역에서는 Compile, Packaging, 단위 Testing을 위한 도구를 사용합니다. Maven은 가장 유명한 Java용 빌드 도구입니다.
테스트 영역에서는 정적 분석, UI 테스트, 통합 테스트, 성능 테스트 등 다양한 테스팅 도구를 사용합니다. SonarQube는 가장 많이 사용하는 정적 분석 도구입니다.
릴리즈/배포 영역에서는 컨테이너를 통해 어플리케이션을 관리할 수 있는 도구를 주로 사용하게 됩니다. 현재는 Docker가 가장 널리 사용되고 있습니다.
운영 영역에서는 Container Orchestration 도구, 그리고 인프라를 토대로 다룰 수 있는 도구를 사용합니다. 모니터링 영역에서는 로깅을 관리하고 가시화하는 대시보드 도구를 주로 사용합니다.
각각 도구를 상세하게 설명 드리겠습니다. Eclipse는 가장 유명한 오픈소스 프로젝트 중 하나입니다. 가장 강력하고 대중적인 통합 개발 환경 도구입니다.
Java를 포함하여 다양한 언어를 지원합니다. 또한 다양한 플러그인을 통해서 확장된 기능을 사용할 수 있습니다.
Spring Tool Suite는 Eclipse를 기반으로 해서 기능을 확장한 도구입니다. Spring Boot라는 Saas 서비스 개발에 용이한 기술을 쉽게 개발할 수 있도록 지원합니다.
2주차 수업에서는 로컬 개발 환경을 직접 구성하여 간단 서비스를 빌드, 테스트해보고 시행할 예정인데, 이때 사용할 도구가 Spring Tool Suite입니다.
Git은 소스코드 관리를 위한 분산형 버전 관리 시스템입니다. 기존에는 중앙통제형 버전 관리 시스템인 Subversion을 주로 사용했지만,
네트워크가 작동되지 않는 환경이나 분산 환경에서 막강한 Git이 대중화되면서 대부분의 프로젝트는 Git을 사용하고 있습니다.
GitHub는 Git을 기반으로 한 글로벌 Git 저장소 서비스입니다. 쉽게 생각해서 GitHub은 Git의 Saas 버전이라고 생각하시면 됩니다.
많은 오픈소스 프로젝트들이 GitHub를 통해서 관리되고 있습니다. GitHub은 단순한 소스코드 저장소가 아니라 개발자 커뮤니티의 중심이라고 볼 수도 있습니다.
2주차 수업에서 글로벌 Git 저장소인 GitHub과 로컬 개발 환경의 Git Client 사용을 실습할 예정입니다.
또한 4주차 수업에서는 설치형 Git 서버인 gitlab을 직접 설치하여 DevOps 환경 구축 실습을 진행할 예정입니다.
Apache Maven은 Java 소스코드를 배포용 산출물로 빌드하기 위한 도구입니다.
소프트웨어 프로젝트 객체 모델이라는 것을 사용하며, 기존의 도구보다 훨씬 더 편리하고 직관적으로 사용할 수 있습니다.
개발자를 힘들게 했던 의존성 관리, 라이브러리 관리와 Compile, Packaging, Test 수행을 쉽게 해줍니다.
2차시 수업에서, 2주차 수업에서 Maven을 활용한 소프트웨어 빌드 실습을 진행해볼 예정입니다.
Jenkins는 지속적 통합을 자동화해주는 가장 유명한 도구입니다.
빌드-테스트-배포를 자동화해주는데, 웹 인터페이스를 통해 간편하게 실행하고, 그리고 플러그인을 통해 확장된 기능을 수행할 수 있습니다.
4주차 수업에서는 Jenkins를 직접 설치해보고, 파이프라인을 설정하여 지속적 통합을 간단하게 실습해볼 예정입니다.
SonarQube는 소스코드 정적 분석을 통해 품질 대시보드를 제공하는 도구입니다. 지속적 통합과 연계하여 소스코드 품질을 점검할 수 있습니다.
소스코드 inspection을 통해서 개발자에게 더 나은 코딩을 가이드해주며, 이를 통해 개발자 역량 및 소스코드 품질을 향상시킬 수 있습니다.
SonarQube의 대시보드는 품질 지표를 직관적으로 제공해주기 때문에 개발자들뿐 아니라 관리자에게도 매우 유용한 도구입니다.
4주차 때 직접 SonarQube를 설치하고, Jenkins를 통해 빌드와 연계하여 소스코드 품질을 측정하는 실습을 진행할 예정입니다.
Docker는 컨테이너 기반으로 어플리케이션을 쉽게 관리할 수 있는 가상화 플랫폼입니다. DevOps와 관련해서 가장 빠르게 발전하고 있는 기술로서 많은 기능들이 확장되었습니다.
컴퓨팅 환경은 개발, 테스트, 운영 등 상황에 따라 매우 다양한 구성을 가집니다. 여기에 관리 대상 숫자가 늘어나게 되면 이를 유지, 관리하는 것이 매우 어렵습니다.
가상화 기술을 활용하면 동일한 환경, 구성을 유지하여 쉽게 관리할 수 있습니다. 가상머신을 사용하는 경우에는 가상머신 설치 때문에 무겁고 성능이 저하되는 문제가 있었습니다.
Docker는 가상 머신을 사용하는 방식보다 가벼운 리눅스 컨테이너 방식을 사용해서 성능 저하 문제를 풀었습니다.
3주차 DevOps를 위한 Docker 실습수업을 통해서 Docker를 더욱 자세하게 알아볼 예정입니다. 앞서 설명 드린 개발 환경 도구들은 모두 Docker를 활용하여 구축할 예정입니다.
지금까지 오픈소스 DevOps 도구들을 소개해드렸습니다. 다음 주차부터는 간단한 실습을 통해서 각 도구들을 직접 사용해보면서 DevOps의 흐름을 체험적으로 알아보도록 하겠습니다.

Week 02

안녕하세요? SK주식회사 C&C 이정민 수석입니다. 오픈소스를 활용한 DevOps 환경의 이해 강좌의 두 번째 시간, DevOps의 기초, 로컬 개발 이해의 강의를 시작하겠습니다.
이번 강의는 DevOps 이해를 위한 가장 기초적인 내용을 담고 있습니다.
본격적인 개발서버 환경 구축 및 통합 환경을 배우기에 앞서 로컬개발에서의 개념들을 먼저 이해한다면 이후 진행되는 강의에 도움이 될 것입니다.
이번 차시는 교육생 분들이 간단히 따라해 볼 수 있는 실습을 포함하였습니다.
실습을 통해서 특정 도구나 기능을 직접적으로 알려드리려는 목적은 아니고 간략히 체험함으로써 로컬에서의 개발 및 환경에 대한 기초개념 이해를 돕고자 하는 목적입니다.
짧은 시간이기 때문에 모든 내용을 설명하는 것이 아니라, 쉽고 간단한 수준에서 소개해드립니다.
이번 강의를 통해서 여러분은 Gitup과 Git을 사용한 분산 환경에서의 소스코드 관리 개념을 이해하실 수 있을 것입니다.
또한 아파치 메이븐을 통해 로컬 개발환경에서의 프로젝트 관리 개념도 이해할 수 있습니다.
첫 번째 차시에서는 로컬 개발환경 이해를 돕기 위한 간단한 형태의 로컬 개발환경을 소개해드리겠습니다. 그리고 로컬 개발환경 구축을 간단하게 따라해보도록 하겠습니다.
지금 보시는 그림은 간단한 형태의 로컬 개발환경입니다. 실제 소프트웨어 개발 프로젝트에서의 개발환경은 매우 다양한 요건과 관련이 있습니다.
비즈니스에 따라서, 프로젝트 목적에 따라서, 기술에 따라서, 개발조직에 따라서 다양한 형태로 개발환경을 구성할 수 있습니다.
지금 소개해드리는 개발환경은 실제 기업의 애플리케이션 개발 프로젝트에서 일반적으로 사용되는 로컬 개발환경을 매우 단순하게 구성한 것입니다.
절대적인 사항은 아니며, 교육을 위해서 간편한 방식을 채택한 부분이 있습니다.
이 개발환경은 자바 기반의 애플리케이션 개발을 위한 것으로 자바 기술이 제일 근간이 됩니다. 개발도구 역시 자바로 개발된 Spring Tool Suite 4를 사용합니다.
Spring Tool Suite 4는 이클립스를 기반으로 한 통합 개발환경 도구로서 이클립스의 기본 기능을 그대로 유지하면서 Spring 애플리케이션 개발을 위한 부가적인 기능들이 추가된 것입니다.
그 중 대표적인 기능이 소스코드 버전 관리를 위해 사용하는 Git 플러그인입니다.
Git 플러그인은 이클립스에서 기본적으로 제공되지 않는데, 이클립스 마켓 플레이스를 통해 추가 설치할 수 있는 기능입니다.
Spring Tool Suite는 별도의 설치 없이 사용할 수 있도록 기본적으로 제공하고 있습니다. 따라서 별도의 Git을 로컬 개발 PC에 설치할 필요는 없습니다.
또한 기본적으로 Git은 명령어 기반 인터페이스를 사용하는데, Git 플러그인은 이클립스와 통합되어 GUI 기반으로 사용할 수 있습니다.
이번 강의에서는 명령어 기반으로 Git을 사용하지 않고 이클립스와 통합된 GUI를 사용할 예정입니다.
또 하나, 애플리케이션 개발의 중요한 요소는 프로젝트 빌드 관리를 위해 사용하는 메이븐입니다.
메이븐 역시 별도로 설치해서 사용할 수 있지만, 이클립스에 통합된 메이븐 기능을 사용할 예정입니다.
로컬 개발환경의 관점은 개발자 개인이 애플리케이션을 개발하는 데 중심이 맞춰져 있습니다. 따라서 개발 PC에 저장되는 로컬 저장소가 중심이 됩니다.
개발팀은 전체가 공유하는 소스코드와 라이브러리는 원격 저장소를 사용해야 하고, 그것은 서버 개발환경에서 다루는 내용이기 때문에 이 부분은 4주차 강의에서 진행할 예정입니다.
가장 기본이 되는 자바 개발도구부터 설명 드리겠습니다. 자바는 대표적인 객체지향 프로그래밍 언어입니다.
JDK는 자바로 개발하기 위해서 필요한 필수적인 도구로서 자바 가상머신, 자바 컴파일러, 자바 API를 포함합니다.
비교해서 설명할 수 있는 JRE는 자바 런타임 환경으로서 자바로 개발된 애플리케이션을 실행할 수 있는 환경을 지칭합니다.
자바는 한 번 작성하면 어디서든지 실행할 수 있다는 것을 내세웁니다.
이를 위해서 필요한 것이 자바 가상머신으로서 자바로 만들어진 애플리케이션은 가상머신에서 동작하며, 자바 가상머신이 설치된 환경이면 어디서든지 실행이 가능합니다.
이것이 가능한 이유는 자바는 특정 머신 전용의 네이티브 코드가 아닌 가상머신을 위한 바이트 코드라는 중간언어로 컴파일되기 때문입니다.
자바를 널리 사용하게 되는 또 하나의 이유는 수많은 API 패키지가 제공된다는 것입니다.
API란 Application Programming Interface로 애플리케이션을 개발할 수 있는 명령어 혹은 라이브러리라고 생각하면 됩니다.
과거에는 GUI, IO, 네트워킹 처리에 있어서 특정 밴더나 기술, 제품에 의존적인 경우가 있었습니다.
하지만 자바의 API는 특정 환경과 관계없이 표준적인 방법으로 사용할 수 있다는 것이 장점입니다.
오라클에서 제공하는 온라인 자바 API 문서를 통해서 자바에 대해서 조금 더 살펴보겠습니다.
굉장히 방대한 양의 전체 API 패키지가 제공됩니다. 입출력을 처리하는 자바 IO, 네트워킹을 처리하는 자바넷. 클릭해서 들어가 보면 더 자세한 설명을 볼 수 있습니다.
클래스가 제공하는 메소드 설명을 통해서 구체적인 기능을 확인할 수 있습니다.
API를 사용하기 위해서는 이처럼 API 문서를 참조하여 원하는 기능과 사용 방법을 확인할 수 있습니다.
오픈 JDK는 자바 스탠다드 에디션 플랫폼의 오픈소스 구현체입니다. 자바는 JCP, 자바 커뮤니티 프로세스를 통해서 표준을 관리합니다.
JCP에서 JAVA Specification Request, JSR에 자바 스펙의 요구사항을 정의하고, 이것의 공식 레퍼런스 구현체가 오픈 JDK입니다.
오라클 JDK는 오픈 JDK 소스를 기반으로 추가적인 플러그인 등이 추가된 것입니다.
오픈 JDK는 링크 예외가 있는 JPL 버전2 라이선스이며, 오라클 JDK는 오라클 바이너리 라이선스에서 구독형 라이선스로 개편되었습니다.
비상업적인 용도에 한해서는 무료 사용이 가능하다고는 하지만, 실습에서는 오픈 JDK를 사용하겠습니다.
오라클 JDK와 오픈 JDK 간에 기술적인 차이는 크게 없습니다. 다만 사용자 지원 측면에서 오픈 JDK의 편의성은 매우 떨어지는 편이기 때문에 설치부터 쉽지는 않습니다.
오픈 JDK 소스를 빌드해서 공유한 사이트 OJDK Build Gitup에 접속해서 다운로드 받아서 설치해보겠습니다.
아래 설명에서 윈도우 설치 파일 다운로드 링크를 확인할 수 있습니다.
윈도우 1.8 버전 64비트 설치 파일을 다운로드하겠습니다. 윈도우가 32비트인 경우에는 아래의 링크를 다운하면 됩니다.
다운로드가 완료되면 설치를 진행합니다. 다운로드 파일을 실행하고 오픈 JDK 런타임에서 자바홈 Variable를 설정하도록 옵션을 조정합니다.
설치가 완료되었으면 제대로 실행이 되는지 테스트합니다.
윈도우 명령 프롬프트를 띄우고 JAVA￢ 버전을 입력하고 실행했을 때 오픈 JDK 1.8이라고 나오면 정상입니다.
스프링은 스프링 프레임워크라는 애플리케이션 개발 프레임워크로 시작해서 현재는 다양한 프로젝트로 확장되었습니다.
자바 API만으로는 최신의 기업용 애플리케이션을 만드는 데 많은 노력이 듭니다.
실제 기업 프로젝트 개발환경에서는 보안 문제, 성능 문제, 생산성 문제, 편의성 등 신경써야 할 부분이 매우 많습니다.
스프링은 실제 프로젝트에서 유용하고 강력한 기능을 굉장히 쉽게 사용할 수 있도록 해줍니다.
스프링 웹사이트에 접속해서 스프링에 대해서 조금 더 살펴보겠습니다.
Spring.io에 접속해보겠습니다. 스프링은 굉장히 많은 기능을 포함하고 있는데, 특히 세 가지를 강조하고 있습니다.
스프링 부트를 통한 Build Anything, 스프링 클라우드를 통한 Cordinate Anything, 스프링 클라우드 데이터플로우를 통한 Connect Everything입니다.
스프링 프레임워크 파일 버전에서는 Reactive Stack이 추가되었는데, 향상된 퍼포먼스를 위해서 비동기 및 Non￢Blocking 처리를 지원합니다.
스프링 부트는 로고의 전원버튼 모양이 의미하는 것처럼 버튼을 누르기만 하면 작동되는 수준처럼 매우 쉽고 빠르게 스프링 기반 애플리케이션을 만들 수 있도록 해줍니다.
스프링 클라우드는 클라우드 기반 분산환경, 특히 마이크로서비스 아키텍처 구현을 위한 서비스 디스커버리, 서킷 브레이커, 오토 컨피규레이션, API 게이트웨이, OAuth 등의 기능을 제공합니다.
스프링 클라우드 데이터플로우는 데이터 통합을 위한 오키스트레이션을 제공합니다.
그 밖에도 스프링은 애플리케이션 개발을 위한 다양한 프로젝트를 지속적으로 확장하고 있습니다.
Spring Tool Suite 4는 스프링 부트 개발을 위한 이클립스 기반의 통합 개발환경입니다.
이클립스를 기반으로 하여 스프링 부트 애플리케이션을 쉽게 개발할 수 있도록 기능을 확장한 것입니다.
Spring Tool Suite는 자바 기반이기 때문에 자바가 설치된 환경에서 실행이 가능합니다. 직접 다운로드해서 설치를 진행해보겠습니다.
Spring Tools 페이지로 이동하여서 다운로드받겠습니다. 이클립스 외에도 비주얼 스튜디오, 아톰 아이디를 위한 버전도 있습니다.
윈도우 32비트용, 윈도우 64비트용 이클립스 Tool Suite를 다운로드하겠습니다.
다운로드가 완료되면 압축을 풀고, STS 4.01 릴리즈 디렉토리를 실습을 위해서 C드라이브 밑에 DevOps라는 디렉토리를 생성해서 이동시키겠습니다.
STS를 실행해보겠습니다. Spring Tool Suite 4을 실행하게 되면 워크스페이스 환경을 설정할 수가 있는데, DevOps 워크스페이스로 변경한 후 론칭했습니다.
Gitup은 분산환경 소스코드 버전관리 도구인 Git의 글로벌 웹 호스팅 서비스입니다.
세계 최대의 오픈소스 공유 플랫폼으로서 공개/비공개 저장소를 제공하고, 코드 리뷰, 문서화, 커뮤니티 등을 제공합니다.
가입하면 무료 서비스를 사용할 수 있으며, 이때는 공개 저장소만 사용이 가능합니다. 공개 저장소는 모두에게 소스코드 내용이 오픈됩니다.
비공개 저장소를 사용하기 위해서는 유료로 서비스를 가입해야 합니다.
2018년 8월 기준 9,600만 개 이상의 프로젝트를 호스팅하고 있고, 3,100만 명 이상의 개발자가 Gitup에 참여하고 있다고 합니다.
2018년 6월 4일, 마이크로소프트 사에서는 75억 달러에 인수하기로 발표하기도 하였습니다.
이번 강의는 로컬 개발 중심으로 서버 개발환경이 없기 때문에 Gitup의 원격 소스코드 저장소를 활용할 예정입니다.
단순히 GitHup의 저장소를 클론할 경우에는 회원가입이 필요 없지만, 직접 원격 저장소를 만들기 위해서는 회원가입이 필요합니다.
웹사이트에 접속해서 회원가입을 진행하겠습니다.
유저 네임을 작성하고 이메일 주소를 작성합니다.
계정을 생성하면 무료 상태로 서비스를 선택하고 나머지 단계는 건너 뛰어도 무방합니다.
가입한 메일로 이메일 주소 확인 메일이 발송되는데, 꼭 이메일 주소를 확인해야 레파지토리를 생성할 수 있습니다.
지금까지 로컬 개발환경 이해를 위한 기본적인 내용을 설명 드렸고, 직접 개발환경도 설치해보았습니다.
다음 차시부터는 설치된 개발도구를 활용하여 직접 사용해보면서 진행해보겠습니다. 감사합니다.

<<<<<<< HEAD
=======

>>>>>>> 124c96ac105b9fe669d7c473722139112bc500c8
소스코드를 개발할 때는 공동의 작업뿐 아니라 개발자 개인의 작업에서도 버전 관리가 필수적입니다.
이번 차시에서는 소스코드 관리를 위하여 Gitup과 Git을 사용한 소스코드 관리 방법에 대해서 알아보겠습니다.
Git의 저장소는 원격 저장소와 로컬 저장소, 두 가지가 있습니다.
원격 저장소는 다수의 인원이 소스코드를 공유하기 위한 공간입니다. 로컬 저장소는 개발자 개인을 위한 저장 공간입니다.
일반적으로 로컬 저장소에서 개발자들이 작업을 하고 공유를 위해서 원격 저장소로 내용을 업로드합니다.
업로드된 내용은 다른 개발자들이 사용하기 위하여 각자의 로컬 저장소로 복제할 수 있습니다.
다수의 개발자들이 소스를 공유할 수 있는 원격 저장소부터 생성해보겠습니다.
퍼스트 레파지토리라는 이름으로 저장소를 생성해볼 텐데, Gitup의 기능을 이용해서 생성하겠습니다.
먼저 Gitup에 로그인합니다.
화면에서 뉴 레파지토리 버튼을 클릭하고 레파지토리 이름에 ‘First￢Repository’를 넣습니다.
리드미 파일을 초기화하도록 체크하고 Create합니다. 레파지토리가 생성되었고, 리드미.md 내용이 표시됩니다.
다음은 생성한 원격 저장소를 로컬 저장소로 복제해보겠습니다. 클론은 Gitup이 아니라 로컬에서 실행해야 합니다.
원격 저장소 정보는 통합 자원 식별자 URI로 표현합니다.
URI는 www.gitup.com 다음에 사용자 계정, 그다음에 레파지토리가 위치하는 형태입니다.
먼저 Gitup에 접속해서 클로날 원격 저장소 정보를 가져오도록 하겠습니다.
Gitup에 로그인한 상태에서 레파지토리를 선택하면 이전에 생성했던 레파지토리가 표시됩니다.
우측에 Clone or Download 버튼을 클릭해서 레파지토리 정보를 클립보드로 복사해야 합니다.
이 URI 정보를 사용해서 로컬 PC로 저장소를 복제할 수 있습니다. STS의 Git URI를 통해서 이후를 진행하겠습니다.
Spring Tool Suite를 실행해서 앞서 설정한 대로 실행을 하고,
상단에 표시되는 메뉴 중에 윈도우 밑에 Preference를 선택하게 되면, 팀 아래에서 Git과 관련된 설정 정보들을 확인할 수 있습니다.
로컬 레파지토리 위치가 표시되고 있습니다. 여기에 로컬 레파지토리 저장소가 다운될 것입니다.
Git GUI를 사용하기 위해서 레파지토리 뷰를 추가하게 되면, STS GUI에서 레파지토리 뷰를 사용할 수 있습니다.
STS Git 클론을 진행해보겠습니다. 클론 링크를 사용해도 되고 위 아이콘을 선택해서 클론할 수 있습니다.
아까 복사한 URI를 붙여놓고 자동으로 호스트와 레파지토리 패스는 들어가게 됩니다.
유저 정보와 패스워드를 입력한 다음에 Next를 선택하고 Finish하게 되면 Gitup의 Git 저장소가 로컬로 복제가 됩니다.
레파지토리의 내용을 STS에서 작업하기 위해서 프로젝트로 등록해보겠습니다.
Import Project를 실행하게 되면 STS에 프로젝트로 등록되게 됩니다.
신규 파일을 등록하여 로컬 저장소에 반영시키는 것을 Commit이라고 합니다. Commit을 하면 변경 내역이 기록되며, 시간순으로 이력을 관리할 수 있습니다.
Commit을 하면 40짜리 고유의 문자열이 생성되는데, 이를 통해서 각각을 식별할 수 있으며, 메시지를 통해서 내용을 구분할 수 있습니다.
따라서 Commit 메시지는 필수적으로 의미 있게 작성해야 합니다.
또한 소스코드 관리를 위해서는 Commit 작업의 단위를 버그 수정, 기능 추가 등 의미 있는 단위로 구분하는 것이 좋습니다.
Commit 절차는 Git 관리를 위한 파일 등록부터 시작합니다. 개발자가 작업은 하지만 Git으로 관리하지 않는 공간을 워킹 트리 작업 공간이라고 합니다.
이 작업 공간의 내용 중 Git으로 관리하기를 원하는 내용만 Commit할 수 있는데, 이를 위한 곳이 인덱스입니다.
워킹 트리의 내용을 저장소에 Commit하기 위해서는 그 사이에 위치한 인덱스에 먼저 등록해야 합니다. 이것을 스테이징이라고 표현하기도 합니다.
스테이징을 활용하면 모든 변경사항을 한 번에 반영하는 것이 아니라 원하는 부분만 선별적으로 Commit할 수 있습니다.
그럼 STS에서 인덱스 등록 및 Commit을 진행해보겠습니다.
로컬 작업 전에 먼저 사용자 정보 이메일과 Name을 설정하겠습니다.
팀의 Git 설정으로 이동해서 Configuration 탭에서 엔트리를 등록합니다. User.email에 Gitup의 이메일 주소를 입력합니다.
그리고 User.name 항목을 또 추가합니다. User.name에 Name을 작성합니다.
이제 워킹 디렉토리에 New.textfile을 생성해서 내용을 넣고 저장해보겠습니다.
파일 앞에 물음표 모양은 아직 Git으로 관리되지 않는 것을 의미합니다.
팀 메뉴에서 Add Index를 통해서 인덱스에 등록하였습니다.
다시 Remove 인덱스를 통해서 제외시킬 수가 있고, 인덱스를 다시 등록하겠습니다.
등록된 파일을 Commit 해보겠습니다. 현재 Staged된 내용으로 내용이 나오게 되고, 마이너스를 하게 되면 다시 Unstaged로 넘어갑니다.
Staging으로 넘긴 다음에 Commit 메세지를 작성하고 Commit을 실행합니다.
지금까지는 로컬 저장소의 사용법을 설명 드렸습니다. Commit된 로컬 저장소의 변경 내용을 원격 저장소로 Push해서 다른 사람들과 공유하는 방법을 설명 드리겠습니다.
로컬 저장소에 변경된 내용을 원격 저장소로 업로드하는 것을 Push라고 합니다.
로컬 저장소와 원격 저장소의 싱크를 맞추면서 다른 사람들과 공동작업을 해나갈 수 있습니다. STS에서 직접 Push를 실행해보겠습니다.
Push할 프로젝트를 선택하고 팀 메뉴에서 Push Branch Master를 실행합니다.
Push를 하게 되면 Push 결과가 표시되고 성공했습니다.
Gitup에서 Push가 성공한 것을 확인할 수 있습니다. 업로드된 파일이 존재하는 것을 알 수 있습니다.
다른 사람이 원격 저장소에서 Push해서 내용이 변경되었다면, 그 변경 내용을 나의 로컬 저장소에도 반영할 필요가 있습니다.
원격 저장소에서 로컬 저장소로 내용을 당겨오는 것을 Pull이라고 합니다.
Pull을 실행하면 원격 저장소에서 최신 변경된 내용을 다운로드하여 내 로컬 저장소에 적용하게 됩니다.
Pull 테스트를 위해서 원격 저장소의 내용을 직접 수정하도록 하겠습니다.
Gitup을 통해서 바로 내용을 수정하고, STS에서 팀 메뉴에서 Pull을 실행해서 변경된 내용을 적용했습니다.
로컬 저장소의 상태가 최신 버전이 아닌 상태에서 이미 변경된 내용을 수정하는 경우에는,
즉 다른 사람이 원격 저장소에 업데이트한 최신 파일과 나의 로컬 저장소의 파일 내용이 충돌하는 경우에 Push 명령은 이제 큐 당하게 됩니다.
이때는 업데이트 내용을 확인하여 Merge 작업을 직접 수행해야 합니다.
Merge를 제대로 하지 않게 된다면 다른 사람의 내용이 날아갈 수가 있습니다.
서버에서 내용을 수정하고 개인 로컬 레파지토리의 내용을 수정했을 때 Push를 했을 때 실패하는 것을 확인할 수 있습니다.
충돌 상황에 대해서는 직접 확인을 해서 Merge를 작업해줘야 합니다.
지금까지 Git 사용의 가장 기초적인 개념을 알아봤습니다. 다음 차시에는 조금 더 발전된 소스코드 관리 개념에 대해서 알아보도록 하겠습니다. 감사합니다.


이번 차시에는 지난 시간에 이어서 Gitup과 Git을 이용한 소스코드 관리를 계속 진행하겠습니다.
일반적으로 기업의 프로젝트나 오픈소스 프로젝트의 경우 원격 저장소의 쓰기 권한을 일반 개발자가 가지고 있지 않고 읽기 권한만 가지고 있는 경우가 많습니다.
그림을 보면 스프링 프로젝트의 스프링 펫 클리닉 저장소를 클론했을 때 나의 로컬에서 작업은 가능하지만,
내용을 수정해서 반영하고 싶은 경우에는 쓰기 권한이 없기 때문에 Push를 할 수가 없습니다.
이때 해당 원격 저장소의 쓰기 권한을 직접적으로 받아내기는 어렵기 때문에
해당 레파지토리를 나의 원격 저장소로 포즈한 다음에 이것을 클론하여 작업하고 Push해서 Pool Request를 요청하여 변경사항에 대한 반영을 요청할 수 있습니다.
요청받은 소스코드 저장소 관리자는 해당 내용을 검토해서 반영 여부를 적용할 수 있습니다.
Gitup에서 샘플 프로젝트, 스프링 펫 클리닉 프로젝트를 검색하여 포크해보겠습니다.
스프링 클리닉으로 검색을 하고 제일 상단에 나오는 스프링 펫 클리닉에 들어가서 상단의 포크 버튼을 클릭합니다.
포크가 완료되면 나의 계정에 저장소가 생성된 것을 확인할 수가 있습니다.
나의 원격 저장소에 저장된 펫 클리닉을 로컬로 복제해 오겠습니다.
포크한 펫 클리닉을 로컬에 복제하였습니다.
해당 프로젝트를 Maven Project로 Import 해보겠습니다.
메뉴에서 Import Maven Project를 선택하고 Finish를 하게 되면 메이븐으로 작성된 펫 클리닉 프로젝트가 Import됩니다.
포크한 애플리케이션이 어떤 애플리케이션인지 실행을 해보면, 펫 클리닉에서 사용하는 간단한 샘플 프로그램입니다.
오너를 등록하고 펫 정보를 등록할 수 있습니다.
오너 이름으로 검색을 하는 간단한 검색 기능이 제공됩니다.
해당 프로젝트의 소스 이력을 한번 살펴보겠습니다.
팀 메뉴에서 히스토리 정보를 보게 되면, 지금까지 소스코드를 관리했던 내역들을 확인할 수 있습니다.
매우 많은 사람들이 오래 전부터 작업을 해온 것을 확인할 수 있습니다.
애플리케이션을 개발하다 보면 소스코드를 공유하면서 여러 버전의 소스코드가 생성이 됩니다.
어떤 개발자는 신규 기능을 추가하게 되고 어떤 개발자는 버그를 수정하기도 하는데, 이때 여러 버전의 코드를 각각 독립적으로 유지/관리하면서도 통합하는 것이 중요합니다.
이를 효과적으로 관리하기 위한 기능이 브랜치입니다. 여러 개발자들이 동시에 다양한 작업을 진행할 수 있게 해줍니다.
독립되고 분리된 상태에서 작업하고 나중에 원래 버전과 비교하며 새로운 버전으로 통합할 수도 있습니다.
그림을 보면 브랜치를 사용하여 동시에 New Feature 작업과 Bug Fix 작업을 진행하고 있습니다.
보통 여러 명이서 동시에 작업을 진행하기 때문에 다른 사람의 작업에 영향을 주지 않게 하기 위해서 신규로 브랜치를 만들게 되고, 작업이 완료된 후에 마스터 브랜치에 통합하게 됩니다.
의미 있는 작업 단위로 분류하여 관리할 수 있기 때문에 관리하기가 편리합니다.
마스터 브랜치는 Git이 기본적으로 생성하는 브랜치 이름입니다.
새로운 브랜치를 만들지 않으면 모든 작업들은 마스터 브랜치에서 이루어집니다. 팀원들과 혼동을 피하기 위해서 브랜치 종류 및 규칙은 사전에 약속해야 합니다.
일반적으로 공통적으로 쓰이는 브랜치 개념이 통합 브랜치와 토픽 브랜치입니다.
통합 브랜치는 항상 배포할 수 있는 버전을 유지하는 브랜치입니다. 따라서 항상 모든 기능이 정상적으로 작동되어야 합니다.
그런데 작업 시 마스터 브랜치에서 바로 작업하게 되면 항상 정상적으로 작동된다는 보장을 하기 어렵기 때문에
기능 추가나 버그 수정 등의 변경작업이 생기면 작업별로 브랜치를 생성해서 진행해야 합니다. 이를 토픽 브랜치라고 합니다.
토픽 브랜치는 통합 브랜치로부터 생성하여 토픽 브랜치의 작업이 완료되면 다시 통합 브랜치에 병합하는 방식을 사용합니다.
개발자가 작업할 브랜치를 미리 선택하기 위해서 브랜치 전환을 할 수 있습니다.
다른 브랜치로 전환하는 것을 체크아웃이라고 합니다. 체크아웃을 실행하면 브랜치가 전환되었기 때문에 Commit을 실행하는 경우에 전환된 브랜치에 적용이 됩니다.
헤드란 현재 사용 중인 브랜치를 가리킵니다. 기본적으로는 마스터의 선두를 나타냅니다.
직접 Git 브랜치를 생성하고 전환해보겠습니다. 팀 메뉴에서 스위치를 통해 뉴 브랜치를 생성할 수 있습니다.
Add Age라는 브랜치를 생성해서 브랜치가 전환된 것을 확인할 수 있습니다. 오너 클래스에 변경하는 코드 내역을 Age를 추가하였습니다.
변경 내역을 Commit하게 되면, 마스터 브랜치로 이동해서 확인했을 때는 방금 작업한 내역이 없고,
실제 Commit했던 Add Age 브랜치로 이동해서 확인을 하게 되면 해당 변경 내역이 들어있는 것을 확인할 수 있습니다.
Add Age 브랜치 작업이 완료되었기 때문에 마스터하고 병합을 해보겠습니다. 마스터 브랜치로 전환한 다음에 Merge 기능을 통해서 마스터 브랜치로 병합하였습니다.
변경한 내역을 Pool Request를 진행하는 것을 진행해보겠습니다.
브랜치를 다시 하나 추가를 하여 메일 정보를 변경합니다.
변경된 브랜치에서 Push를 하게 되면 자동으로 Pool Request 정보로 이동해서 Pool Request를 요청할 수 있습니다.
지금까지 Gitup과 Git을 이용한 소스코드 관리, 포크, 브랜치, Pool Request 개념에 대해서 알아보았습니다. 감사합니다.


0:15 / 16:45Press UP to enter the speed menu then use the UP and DOWN arrow keys to navigate the different speeds, then press ENTER to change to the selected speed.속도1.50x동영상의 음소거 혹은 음소거 해제를 위해 이 버튼을 클릭하거나, 볼륨을 높이거나 낮추기 위해 UP 버튼 혹은 DOWN 버튼을 눌러주세요.크게 볼륨.동영상 자막
자막의 시작.끝으로 이동
이번 차시에서는 아파치 메이븐 도구를 통해서 프로젝트 빌드 관리 개념을 알아보도록 하겠습니다.
아파치 메이븐은 독립적으로 설치/실행할 수 있고 명령어 기반, 즉 Command 라인 인터페이스로 사용할 수 있습니다.
하지만 본 강의에서는 STS의 통합된 플러그인을 통해서 UI 기반으로 진행할 예정입니다.
아파치 메이븐은 소프트웨어 객체 모델 기반의 프로젝트 관리 도구입니다. 프로젝트 관리에 필요한 대부분의 작업들을 표준화했고 자동화하였습니다.
프로젝트 관리를 위한 여러 요소들에 대해서 일관된 기준을 제시해줍니다.
예를 들어 디렉토리 구조의 경우 프로젝트마다 혹은 개발자마다 다른 구조를 가져갈 수 있는데, 메이븐을 사용하게 되면 표준에 가깝게 정형화된 구조를 사용하여 많은 혼란을 줄일 수 있습니다.
빌드 절차 역시 메이븐에서 추상화한 프로세스를 따르면 일관된 방식으로 프로젝트를 관리/운영할 수 있습니다.
메이븐의 또 하나의 가장 큰 장점은 자동화된 의존성 관리입니다.
소프트웨어를 개발하다 보면 재사용을 높이기 위하여 모듈화하는 경우가 많고,
여러 개의 구성요소를 조합해야 할 경우가 많습니다. 게다가 오픈소스 라이브러리 사용도 증가하면서 관리해야 할 외부 라이브러리까지 증가하면서 프로젝트의 복잡도는 더욱 높아집니다.
이때 의존 관계에 있는 라이브러리를 관리하는 작업은 매우 번거로운 일입니다.
메이븐은 라이브러리 저장소를 통해 의존 관계에 있는 라이브러리를 자동으로 관리해줍니다.
메이븐의 많은 기능들은 플러그인을 통해서 확장할 수 있습니다.
소스코드 자동 생성이나 리포팅을 위한 작업 등 반복적인 작업을 자동화하는 편의 기능들이 플러그인을 통해 지원됩니다.
소프트웨어 개발은 구조화를 지향하기 때문에 많은 프로젝트의 경우 유사성을 가지게 됩니다.
메이븐은 아키타입 기능을 통해 반복적인 작업을 해소하고 자동화된 프로젝트 관리를 위한 표준화된 탬플릿을 제공합니다.
이를 사용하면 새로운 프로젝트를 시작할 때마다 반복되는 어려움을 덜어줄 수 있습니다.
메이븐은 크게 두 종류의 환경설정이 있습니다. 하나는 세팅 설정이고 하나는 폼 설정입니다. 두 가지 다 XML 파일 형식으로 되어 있어 확장자는 XML로 끝납니다.
세팅 지점 XML은 메이븐 홈 디렉토리 아래에 위치합니다.
메이븐 빌드 시 다운로드 되는 라이브러리의 로컬 저장소의 경로를 지정하거나 사용자별 프로파일 정보를 설정할 수 있습니다. 여기서는 크게 다루지 않겠습니다.
Pom.xml 파일은 메이븐을 사용하는 프로젝트마다 하나씩 필요한 설정 파일입니다.
폼(Pom)은 Project Object Model의 줄임말로 프로젝트 객체 모델이라는 형식으로 프로젝트와 관련된 정보를 관리합니다.
폼이 관리하는 정보를 크게 분류해보면 프로젝트의 기본 정보를 나타내는 정보, 메이븐 내부에서 반복적으로 사용되는 상수 값을 정의하는 속성 정보,
다른 라이브러리와의 의존관계를 나타내는 의존성 정보 그리고 프로젝트 빌드를 위한 정보로서 플러그인 정보나 빌드 환경을 관리하는 정보 등으로 구분할 수 있습니다.
이 중 프로젝트 기본 정보는 모델 버전, 그룹 아이디, Aartifact 아이디, 버전, 패키징 정보를 설정합니다.
모델 버전은 메이븐의 모델 버전을 나타내는 것으로 변경할 경우가 거의 없습니다.
그룹 아이디와 Aartifact 아이디는 메이븐에서 프로젝트를 구분하기 위해 사용되는 고유 값을 가지는 식별자입니다.
그룹 아이디는 일반적으로 조직의 도메인 명을 사용하게 되고, Aartifact 아이디는 프로젝트 이름을 사용하게 됩니다.
버전 정보는 프로젝트의 버전을 나타내며, 패키징 정보는 자르, 와르, 폼 등의 패키징 형태를 정의합니다.
메이븐의 기본적인 설정과 플러그인 정보를 포함하고 있는 최상위 폼이 있고, 모든 메이븐 파일은 이를 상속받습니다.
STS에서 메이븐 환경설정과 관련된 부분을 알아보고 실제 프로젝트의 Pom.xml 정보를 살펴보겠습니다.
Preference에서 메이븐 메뉴를 통해 메이븐 설정 정보를 확인할 수 있습니다.
유저 세팅을 선택하게 되면 Settings XML 파일과 레파지토리 위치를 확인할 수 있습니다.
실제 프로젝트의 Pom.xml 파일을 보게 되면, 프로젝트 모델 정보와 프로젝트의 정보, Property 정보, 의존성 정보들을 확인할 수 있습니다.
빌드와 플러그인 정보도 정의되어 있는 것을 확인할 수 있습니다.
메이븐의 표준 디렉토리 구조는 다음과 같습니다. 주요 색상이 칠해진 디렉토리가 실제 개발과 가장 큰 관련이 있는 부분입니다.
SRC 밑에, 메인 밑에, 자바 디렉토리 아래에 애플리케이션 소스파일이 위치하고, Resources 디렉토리에는 애플리케이션 설정 파일이나 자원 파일들이 위치합니다.
SRC 테스트 아래에 자바 디렉토리에서는 테스트 소스파일이 위치하고, 마찬가지로 Resources 디렉토리 아래에서 테스트를 위한 설정 파일이나 자원 파일을 위치하게 됩니다.
디렉토리 설정은 Pom.xml 환경설정에서 변경할 수도 있습니다.
실제 프로젝트의 디렉토리 내용을 살펴보겠습니다. 소스 밑에, 메인 밑에, 자바 밑에 소스파일들이 위치합니다.
Resource 밑에는 환경설정 파일과 여러 가지 자원 파일들이 위치해 있습니다. 테스트 밑에는 테스트 파일이 위치해 있습니다.
메이븐은 빌드 공정을 미리 정의하고 있으며, 세 가지 형태의 수명주기로 구분하고 있습니다.
각 수명주기는 페이지라고 하는 단계로 구성되어 있습니다. 빌드 수명주기는 컴파일, 테스트, 패키징, 인스톨, 디플로이의 단계를 거칩니다.
컴파일은 소스코드를 컴파일하는 단계입니다. 테스트는 단위 테스트를 수행하는 단계이고, 이 단계가 실패하는 경우 빌드가 실패합니다.
패키징은 패키징의 종류에 따라 결과물을 압축하는 단계입니다. 인스톨은 로컬 환경의 로컬 저장소에 패키징한 결과물을 배포하는 단계입니다.
디플로이는 원격 저장소에 패키징한 결과물을 배포하는 단계입니다.
모든 페이지는 앞단의 페이지에 의존적입니다. 이 얘기는 디플로이는 인스톨을 실행하고, 인스톨은 패키지를, 패키지는 테스트를, 테스트는 컴파일을 실행하게 됩니다.
로컬 저장소와 원격 저장소는 나중에 설명 드릴 예정입니다.
클린 수명주기는 클린 단계로 구성되는데, 메이븐 빌드를 통해 생성된 산출물을 삭제합니다.
일반적으로 빌드 결과물은 타깃 디렉토리 밑에 생성이 되고, 클린을 수행하면 타깃 밑의 모든 내용이 삭제됩니다.
사이트 수명주기는 프로젝트의 문서 정보를 생성합니다. 사이트 페이지는 문서 산출물을 생성하고 사이트 디플로이 페이지는 문서 산출물을 서버에 배포합니다.
컴파일 페이지에 대해서 더 자세히 알아보겠습니다. 컴파일하기 전에 먼저 자원을 복사하는 작업부터 시작됩니다.
소스코드 및 자원 파일을 타깃 디렉토리로 복사한 후 소스코드를 컴파일합니다. 컴파일을 위한 버전 정보, 인코딩 정보 등은 컴파일러 플러그인을 통해 설정할 수 있습니다.
일반 소스코드에 대해서 작업이 끝난 다음에는 테스트 소스코드와 자원을 타깃 디렉토리로 복사한 후 테스트 코드에 대한 컴파일을 수행합니다.
STS에서 직접 메이븐 컴파일을 실행해보겠습니다.
컴파일할 프로젝트를 선택을 하고 Run As에서 메이븐, 빌드, 골에 테스트 컴파일을 입력합니다.
컴파일이 수행되는 과정을 보실 수 있습니다.
컴파일의 다음 페이지가 테스트입니다. 테스트 단계에서는 앞서 컴파일한 단위 테스트 코드를 실행하게 되며, 테스트 결과물에 대한 산출물을 생성합니다.
단위 테스트 과정에서 테스트가 실패한 경우에는 다음 단계로 진행되지 않습니다.
단위 테스트가 실패하더라도 다음 단계 진행을 하려면 테스트 스킵 속성을 True로 설정하고 빌드를 진행해야 합니다. 직접 테스트를 수행해보겠습니다.
Run As에서 메이븐 테스트를 실행하면 메이븐 테스트가 실행됩니다. 컴파일을 하고 테스트가 시작되었습니다.
작성된 테스트 코드가 실행이 되고 테스트 결과가 표시되고 있으며, 실패하는 경우에는 Fail이 뜨게 됩니다.
테스트가 성공하였습니다. 40개의 테스트가 성공했고 스킵이 1개 되었습니다.
컴파일과 테스트가 완료되면 빌드 산출물을 자르(Jar) 또는 와르(War) 로 패키징하게 됩니다.
패키징 다음에는 배포해야 하는데 인스톨은 로컬 저장소까지 배포하는 것이고, 디플로이는 원격 저장소까지 배포하는 것입니다.
클린은 타깃 디렉토리의 모든 내용을 삭제합니다. 경우에 따라서 이전에 빌드했던 결과물이 영향을 주기 때문에 빌드 오류가 발생할 수 있습니다.
이때는 명시적으로 클린을 수행한 다음에 다시 빌드를 수행해야 합니다.
일반 개발자가 임의로 여기에 라이브러리를 배포할 수 없습니다.
보통 메이븐 빌드 시 중앙 저장소의 라이브러리를 로컬로 가져올 때 사용하게 됩니다.
원격 저장소는 모든 라이브러리가 중앙 저장소에 있는 것이 아니기 때문에 별도로 저장소를 사용하는 것입니다.
스프링 같은 경우에는 외부에 공개되는 저장소를 운영하지만, 보통 사내 또는 프로젝트용으로 구축하여 사용하게 됩니다.
로컬 저장소는 개발자 PC의 저장소를 말합니다. 빌드를 위해서 다운로드되는 라이브러리들이 정해진 위치에 다운로드됩니다.
지금 보시는 화면이 의존성이 있는 라이브러리를 설정한 내용이고, 아래쪽 저장소의 정보가 설정되어 있습니다. 원격 저장소의 정보가 설정되어 있습니다.
개인 로컬 저장소 위치에 들어가면 다운로드된 파일들을 확인할 수 있습니다.
메이븐 업데이트 프로젝트를 통해서 빌드에 필요한 라이브러리를 다운로드받고 있습니다.
의존성에 따라서 자동으로 다운로드되고, 로컬에 없는 경우에 중앙 저장소 혹은 원격 저장소의 내용을 다운로드받게 됩니다.
프로젝트는 하나의 프로젝트로 진행할 수도 있고, 규모가 커지는 경우 프로젝트를 분리하기도 합니다.
최근에 마이크로서비스의 경우에는 매우 작은 단위로 프로젝트를 구성하기 때문에 멀티 모듈프로젝트로 관리하는 경우가 많습니다.
메이븐의 모든 설정은 최상위 폼을 상속하고 있습니다. 필요시에는 Parent 폼을 만들고, 그 Parent 폼을 상속받게 할 수 있습니다.
프로젝트에서 공통적으로 사용할 수 있는 모드를 상위 폼으로 활용할 수도 있습니다.
의존성이 있는 상태에서 프로젝트가 여러 모듈로 분리되는 경우에는 빌드하는 것이 쉽지 않습니다.
모듈 줄 설정을 통해서 여러 모듈을 한 번에 빌드할 수 있습니다. 모듈 간의 의존성은 기존의 Dependancy 설정과 동일하게 설정하여 사용도 합니다.
멀티 모듈 프로젝트로 구성한 예시를 살펴보겠습니다.
펫 클리닉 프로젝트의 마이크로서비스 버전을 클론하겠습니다.
메이븐 프로젝트로 Import하고 프로젝트 창에 표시되는 프로젝트들이 다수인 것을 확인할 수 있습니다.
그 중에 Parent가 되는 프로젝트 정보를 보게 되면 모듈 줄로 멀티 모듈 설정이 되어 있습니다.
각 개별 서비스도 자신의 폼 정보를 가지고 있으며 Parent 정보를 상속받습니다.
상위 프로젝트를 빌드하게 되면 멀티 모듈 프로젝트 전체를 통합적으로 빌드하는 것을 확인할 수 있습니다.
자체 저장소와 아키타입 등을 활용하면 공통 탬플릿이나 라이브러리 또는 샘플 프로젝트 전파에 유용합니다.
렉서스를 사용하여 직접 원격 저장소를 구축하여 운영할 수 있습니다.
사내의 표준 프레임워크 등의 아키타입을 사용하면 메이븐에서 제공하는 아키타입처럼 원하는 탬플릿으로 프로젝트 뼈대를 제공할 수 있습니다.
프로젝트 시작부터 공통 라이브러리, 공통 설정, 샘플 소스 등을 쉽게 제공해서 프로젝트의 생산성 향상에 도움이 됩니다.
지금까지 메이븐을 활용한 로컬 개발환경 프로젝트 빌드 관리에 대해서 살펴보았습니다. 감사합니다.

메이븐과 깃은 어떤 차이?
DevOps는 다양한 툴이 있나?
